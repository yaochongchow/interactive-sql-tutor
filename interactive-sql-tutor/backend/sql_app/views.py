from django.shortcuts import render

# Create your views here.
from rest_framework.decorators import api_view
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import SQLProblem, Attempt, Topic
from .serializers import SQLProblemListSerializer, SQLProblemDetailSerializer, AttemptSerializer, AttemptHistorySerializer 
from .serializers import ProblemUploadSerializer, SQLQuerySerializer
from utils.sql_sandbox import check_user_query
from rest_framework.permissions import IsAuthenticated
from django.db.models import Count, Case, When, IntegerField, FloatField, ExpressionWrapper, Value, F, Func

import os, json
from django.conf import settings
from .permissions import IsAdminUserOrInstructor
from django.db import connection
from utils.save_sql_problem_to_db import save_sql_problem_to_db
from sqlglot import parse_one, exp
from utils.problem_loader import get_next_problem_id
from utils.gcs_uploader import upload_problem_to_gcs
from google.cloud import storage

@api_view(['GET'])
def problem_list(request):
    """
    Retrieves a list of all available SQL problems, with optional filtering and annotated acceptance rates.

    This endpoint returns a simplified list of SQL problems, including:
    - Problem ID
    - Title
    - Difficulty level
    - Topic name
    - Acceptance rate (rounded to 2 decimal places)

    The data is ordered by `problem_id` in ascending order.

    Method: GET  
    URL: /api/sql-problems/

    Query Parameters:
    - difficulty (str): Filter by difficulty level (e.g., Easy, Medium, Hard)
    - topic (str): Filter by topic name (e.g., JOIN, Aggregation)

    Features:
    - Results are ordered by `problem_id` in ascending order
    - Filtering is case-insensitive
    - Acceptance rate is precomputed (Completed attempts / Total attempts)

    Example:
        GET /api/problems/?difficulty=Easy&topic=JOIN

    Response Example:
    [
        {
            "problem_id": 1,
            "title": "Find Top Seller",
            "difficulty_level": "Medium",
            "topic": "Aggregation",
            "acceptance": 83.33
        },
        {
            "problem_id": 2,
            "title": "Employees Without Managers",
            "difficulty_level": "Easy",
            "topic": "JOIN",
            "acceptance": 100.0
        }
    ]

    Returns:
        Response: A JSON list of problems serialized via `SQLProblemListSerializer`.
    """
    queryset = SQLProblem.objects.all()

    # Get query params
    difficulty = request.GET.get('difficulty')
    topic = request.GET.get('topic')

    if difficulty:
        queryset = queryset.filter(difficulty_level__iexact=difficulty)

    if topic:
        queryset = queryset.filter(topic__name__iexact=topic)

    # Annotate acceptance
    queryset = queryset.annotate(
        total_attempts=Count("attempts"),
        successful_attempts=Count(
            Case(
                When(attempts__status="Completed", then=1),
                output_field=IntegerField()
            )
        ),
        raw_acceptance=ExpressionWrapper(
            Case(
                When(total_attempts__gt=0,
                     then=F('successful_attempts') * 100.0 / F('total_attempts')),
                default=Value(0.0),
                output_field=FloatField()
            ),
            output_field=FloatField()
        ),
        acceptance=Func(F('raw_acceptance'), function='ROUND', template='ROUND(%(expressions)s, 2)')
    ).order_by('problem_id')

    serializer = SQLProblemListSerializer(queryset, many=True)
    return Response(serializer.data)

@api_view(['GET'])
def problem_detail(request, problem_id):
    """
    Retrieves detailed information for a specific SQL problem.

    This endpoint returns comprehensive data about the problem, including:
    - Title, description, and difficulty level
    - Topic name
    - Whether result order matters
    - Table schemas
    - Hints
    - Expected output (generated by running solution.sql)

    Method: GET  
    URL: /api/problems/<problem_id>/

    Parameters:
        problem_id (int): The ID of the SQL problem to retrieve.

    Responses:
        200 OK:
            {
                "problem_id": 3,
                "title": "Find Active Users",
                "description": "...",
                "difficulty_level": "Medium",
                "topic": "JOIN",
                "requires_order": false,
                "tables": [...],
                "input_data",
                "hints": [...],
                "expected_output": [...],
                "acceptance": value (float)
            }

        404 Not Found:
            {
                "error": "Problem not found."
            }

    Returns:
        Response: A JSON object with full problem details serialized using `SQLProblemDetailSerializer`.
    """
    try:
        problem = SQLProblem.objects.get(problem_id=problem_id)
    except SQLProblem.DoesNotExist:
        return Response({"error": "Problem not found."}, status=status.HTTP_404_NOT_FOUND)

    serializer = SQLProblemDetailSerializer(problem)
    return Response(serializer.data)

class AttemptSubmitView(APIView):
    """
    Handles the submission of a user's SQL query for a specific problem.

    Endpoint: POST /api/problems/<problem_id>/submit/

    Features:
    - Requires authentication via `IsAuthenticated`.
    - Accepts the user's query and optional metadata (e.g., hints used, time taken).
    - Validates and checks the SQL query in a sandboxed environment.
    - Computes score and status based on correctness.
    - Saves the result as an Attempt object.
    - Returns feedback and result status in the response.

    Request Body:
        {
            "user_query": "SELECT * FROM ...",
            "hints_used": 1,          # optional
            "time_taken": 120         # optional
        }

    Successful Response (200 OK):
        {
            "result": "correct",
            "score": 100,
            "feedback": ""
        }

    Failure Response (400 / 404):
        {
            "error": "Problem not found."
        }

        OR

        {
            "user_query": ["This field is required."]
        }

    Parameters:
        problem_id (int): The ID of the SQL problem being attempted.

    Permissions:
        - Requires the user to be authenticated.
    """
    permission_classes = [IsAuthenticated]

    def post(self, request, problem_id):
        user = request.user
        try:
            problem = SQLProblem.objects.get(problem_id=problem_id)
        except SQLProblem.DoesNotExist:
            return Response({"error": "Problem not found."}, status=status.HTTP_404_NOT_FOUND)

        serializer = AttemptSerializer(data=request.data, partial=True)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        data = serializer.validated_data
        user_query = data.get("user_query")
        hints_used = data.get("hints_used", 0)
        time_taken = data.get("time_taken", None)

        # Run sandboxed check on the user's SQL query
        correct, message = check_user_query(problem_id, user_query)

        score = 100 if correct else 0
        status_str = "Completed" if correct else "Failed"

        # Save the attempt record
        attempt = serializer.save(
            user=user,
            problem=problem,
            score=score,
            status=status_str,
            hints_used=hints_used,
            time_taken=time_taken
        )

        return Response({
            "result": "correct" if correct else "wrong",
            "score": score,
            "feedback": message
        }, status=status.HTTP_200_OK)


class AttemptHistoryView(APIView):
    """
    API endpoint to retrieve a user's submission history for a specific SQL problem.

    Method:
        GET

    URL:
        /api/problems/<problem_id>/history/

    Permissions:
        - Requires authentication (JWT token)

    Request Parameters:
        - problem_id (int): The ID of the SQL problem

    Behavior:
        - Checks if the problem exists
        - Retrieves all attempts made by the current user for the specified problem
        - Orders attempts by submission date (most recent first)

    Response (200 OK):
        Returns a list of attempt records with the following fields:
        [
            {
                "submission_date": "2024-04-01T14:32:00Z",
                "score": 100.0,
                "time_taken": 120,
                "status": "Completed",
                "hints_used": 1
            },
            ...
        ]

    Response (404 Not Found):
        {
            "error": "Problem not found"
        }
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, problem_id):
        user = request.user

        # Check if the problem exists
        try:
            problem = SQLProblem.objects.get(problem_id=problem_id)
        except SQLProblem.DoesNotExist:
            return Response({"error": "Problem not found"}, status=status.HTTP_404_NOT_FOUND)

        # Retrieve the user's submission history for this problem (ordered by most recent)
        attempts = Attempt.objects.filter(user=user, problem=problem).order_by('-submission_date')
        serializer = AttemptHistorySerializer(attempts, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

class ProblemFiltersView(APIView):
    """
    API endpoint for retrieving distinct filter options for SQL problems.

    Method: GET  
    URL: /api/problems/filters/

    Purpose:
    - Provides available topic names and difficulty levels for frontend filter dropdowns.

    Returns:
        200 OK with JSON object:
        {
            "topics": ["Aggregation", "Join", "Window Functions", ...],
            "difficulty_levels": ["Easy", "Medium", "Hard", "Expert"]
        }
    """
    def get(self, request):
        topics = Topic.objects.values_list("name", flat=True).distinct()
        difficulties = SQLProblem.objects.values_list("difficulty_level", flat=True).distinct()
        return Response({
            "topics": sorted(topics),
            "difficulty_levels": sorted(difficulties)
        }, status=status.HTTP_200_OK)

class UploadSQLProblemView(APIView):
    """
    API endpoint for uploading a new SQL problem to the platform.

    Permission:
        - Requires authentication (`IsAuthenticated`)
        - Only accessible to users with role: Admin or Instructor (`IsAdminUserOrInstructor`)

    Request Method:
        POST

    Request Headers:
        Authorization: Bearer <access_token>  # Required for JWT authentication

    Request Body (multipart/form-data):
        - metadata (JSON string):
            A JSON string that includes:
                - title (str): The name of the SQL problem.
                - description (str): A detailed description of the problem statement.
                - difficulty_level (str): One of ['Easy', 'Medium', 'Hard', 'Expert'].
                - topic_id (int): ID referencing the related topic (foreign key).
                - requires_order (bool): Whether the result order should be considered in output comparison.
                - tables (list): A list of table schema definitions for the problem.
                - input_data (dict): The initial table data for the problem (for UI display or debugging).
                - hints (list): A list of string hints associated with the problem.
                - expected_output (list): The expected result rows (as dicts) from executing the solution query.
        
        *** Note: Do NOT include `problem_id` in the metadata. ***
        It will be automatically generated by the server upon upload.

        - problem_file (file): A `.sql` file containing DDL + sample data (CREATE + INSERT)
        - solution_file (file): A `.sql` file containing the correct SELECT query

    Process:
        1. Validates the metadata and uploaded files.
        2. Generates a new unique problem_id based on existing folders.
        3. Creates a new subdirectory under `problems/{id}/` to store:
            - metadata.json
            - problem.sql
            - solution.sql
        4. Inserts the metadata and hints into the SQLProblem and Hint tables via raw SQL.

    Returns:
        - 201 Created: Problem uploaded successfully
        - 400 Bad Request: Invalid data or duplicate problem ID folder
        - 500 Internal Server Error: Unexpected error during processing

    Example Response (Success):
        {
            "message": "Problem 004 uploaded successfully."
        }

    Notes:
        - This endpoint is designed for backend/admin use to populate the SQL practice problem set.
        - It assumes the database schema already exists and model `managed = False`.
    """
    permission_classes = [IsAuthenticated, IsAdminUserOrInstructor]

    def post(self, request):
        serializer = ProblemUploadSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        try:
            # Generate new problem_id
            metadata = serializer.get_validated_metadata()
            files = serializer.get_cleaned_files()
            new_id = get_next_problem_id()
            folder = str(new_id).zfill(3)

            # Check for duplicates
            client = storage.Client()
            bucket = client.bucket(settings.GCS_PROBLEM_BUCKET)
            gcs_conflict = any(blob.name.startswith(f"problems/{folder}/") for blob in bucket.list_blobs(prefix=f"problems/{folder}/"))
            local_path = os.path.join(settings.BASE_DIR, "problems", folder)
            if gcs_conflict or os.path.exists(local_path):
                return Response({"error": f"Problem {new_id} already exists."}, status=400)

            # Update metadata and write
            metadata_with_id = {"problem_id": new_id, **metadata}
            files["metadata.json"] = json.dumps(metadata_with_id, indent=2)
            upload_problem_to_gcs(new_id, files)

            with connection.cursor() as cursor:
                save_sql_problem_to_db(cursor, metadata_with_id)

            return Response({"message": f"Problem {new_id} uploaded successfully."}, status=201)

        except Exception as e:
            return Response({"error": str(e)}, status=500)

class InstructorQueryAPIView(APIView):
    """
    API endpoint for instructors to execute SQL queries 
    and retrieve data related to student performance.

    Permissions:
        - Requires authentication (`IsAuthenticated`)
        - Requires user role: 'Instructor' or 'Admin' (`IsAdminUserOrInstructor`)

    Accepted Query Types:
        - Only SELECT or WITH queries are allowed.
        - Queries must NOT contain forbidden keywords:
            DROP, DELETE, INSERT, UPDATE, ALTER, CREATE
        - Returned result columns must all be in the allowed whitelist.
    """
    permission_classes = [IsAuthenticated, IsAdminUserOrInstructor]
    ALLOWED_COLUMNS = {
        "User": ["user_id", "name", "email", "role", "date_joined"],
        "SQLProblem": ["problem_id", "title", "difficulty_level", "topic_id"],
        "Attempt": ["attempt_id", "user_id", "problem_id", "score", "status", "time_taken", "submission_date", "hint_used"],
        "Topic": ["topic_id", "name"]
    }

    def are_selected_columns_allowed(self, query: str, ALLOWED_COLUMNS: dict) -> bool:
        """
        Check if all columns used in the SQL query are within the allowed whitelist,
        using SQL parser to support aliases (AS), JOINs, subqueries, and CTEs.

        Args:
            query (str): The raw SQL query string submitted by the instructor.
            ALLOWED_COLUMNS (Dict[str, List[str]]): A mapping of allowed columns per table.

        Returns:
            bool: True if all original columns used in the query are allowed; False otherwise.
        """
        try:
            parsed = parse_one(query)

            # Build alias ➝ real table name mapping
            table_alias_map = {}  # e.g., {"a": "Attempt"}
            for table in parsed.find_all(exp.Table):
                alias = table.alias_or_name  # uses alias if present, fallback to name
                table_alias_map[alias] = table.name

            # Derive real referenced tables
            referenced_tables = set(table_alias_map.values())

            # 1. Reject SELECT * or table.* for safety
            for star in parsed.find_all(exp.Star):
                parent = star.parent
                if isinstance(parent, exp.Select) or isinstance(parent, exp.Alias):
                    table_node = parent.args.get("this")
                    if table_node:  # e.g., a.*
                        table_name = table_node.name
                        if table_name not in table_alias_map:
                            return False
                        resolved_table = table_alias_map.get(table_name)
                        if resolved_table not in ALLOWED_COLUMNS:
                            return False
                        return False  # Reject table.* even if table is allowed
                    else:
                        return False  # Reject SELECT * (no table prefix)

            # 2. Check SELECT columns against whitelist
            SENSITIVE_FIELDS = {"password", "hashed_password", "salt"}

            for col in parsed.find_all(exp.Column):
                col_name = col.name
                col_table = col.table

                # Block sensitive fields regardless of alias
                if col_name.lower() in SENSITIVE_FIELDS:
                    return False

                if col_table:
                    resolved_table = table_alias_map.get(col_table)
                    if not resolved_table:
                        return False
                    if resolved_table not in ALLOWED_COLUMNS:
                        return False
                    if col_name not in ALLOWED_COLUMNS[resolved_table]:
                        return False
                else:
                    # No table name specified, search all referenced tables
                    found = False
                    for table in referenced_tables:
                        if table in ALLOWED_COLUMNS and col_name in ALLOWED_COLUMNS[table]:
                            found = True
                            break
                    if not found:
                        return False

            return True
        
        except Exception as e:
            # If we can't parse the query, reject it
            print(f"Error parsing SQL query: {e}")
            return False
    
    def post(self, request):
        """
        POST /instructor/query-sql/

        Accepts a SQL SELECT query and returns the query result if valid.

        Request Body (application/json):
            {
                "query": "<SQL SELECT statement>"
            }

        Response:
            200 OK:
                {
                    "columns": ["col1", "col2", ...],
                    "rows": [[val1, val2], [val3, val4], ...]
                }
            400 Bad Request:
                {
                    "error": "Validation or execution error message"
                }
            403 Forbidden:
                {
                    "error": "Some columns are not allowed."
                }
        """
        serializer = SQLQuerySerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=400)

        query = serializer.validated_data["query"]

        if not self.is_safe_query(query):
            return Response({"error": "Only safe SELECT queries are allowed."}, status=400)
        
        if not self.are_selected_columns_allowed(query, self.ALLOWED_COLUMNS):
            return Response({"error": "Some columns are not allowed."}, status=403)
        try:
            with connection.cursor() as cursor:
                cursor.execute(query)
                columns = [col[0] for col in cursor.description]
                rows = cursor.fetchall()
            # if not self.are_selected_columns_allowed(columns, self.ALLOWED_COLUMNS):
            #     return Response({"error": "Some columns are not allowed."}, status=403)
            return Response({"columns": columns, "rows": rows}, status=200)

        except Exception as e:
            return Response({"error": str(e)}, status=400)
        
    def is_safe_query(self, query):
        """
        Check if the query starts with SELECT or WITH 
        and contains no forbidden keywords.

        Args:
            query (str): SQL query string submitted by the instructor.

        Returns:
            bool: True if query is considered safe, False otherwise.
        """
        safe_starts = ["select", "with"]
        forbidden = ["drop", "delete", "insert", "update", "alter", "create"]

        query_lower = query.lower().strip()
        
        return (
            any(query_lower.startswith(start) for start in safe_starts)
            and not any(f in query_lower for f in forbidden)
        )

class AllowedSchemaAPIView(APIView):
    """
    API endpoint that returns the list of allowed tables and their column definitions
    for use in instructor SQL queries.

    Permissions:
        - Requires authentication (`IsAuthenticated`)
        - Requires user role: 'Instructor' or 'Admin' (`IsAdminUserOrInstructor`)

    Purpose:
        - Provides the front-end (or client) with metadata about which tables and columns
          are permitted in SQL query execution by instructors.

    Response Format:
        200 OK:
        {
            "User": [
                {"name": "user_id", "type": "int"},
                {"name": "name", "type": "varchar"},
                ...
            ],
            "Attempt": [
                {"name": "user_id", "type": "int"},
                {"name": "problem_id", "type": "int"},
                ...
            ],
            ...
        }

    Notes:
        - This schema is based on a static whitelist and is not dynamically generated.
        - It should match the back-end's `ALLOWED_COLUMNS` used for query validation.
    """
    permission_classes = [IsAuthenticated, IsAdminUserOrInstructor]

    def get(self, request):
        schema = {
            "User": [
                {"name": "user_id", "type": "int"},
                {"name": "name", "type": "varchar"},
                {"name": "email", "type": "varchar"},
                {"name": "role", "type": "enum('Student', 'Instructor', 'Admin')"},
                {"name": "date_joined", "type": "datetime"}
            ],
            "SQLProblem": [
                {"name": "problem_id", "type": "int"},
                {"name": "title", "type": "varchar"},
                {"name": "difficulty_level", "type": "enum('Easy', 'Medium', 'Hard', 'Expert')"},
                {"name": "topic_id", "type": "int"}
            ],
            "Attempt": [
                {"name": "user_id", "type": "int"},
                {"name": "problem_id", "type": "int"},
                {"name": "score", "type": "decimal"},
                {"name": "status", "type": "enum('Completed', 'Failed')"},
                {"name": "time_taken", "type": "int"},
                {"name": "submission_date", "type": "datetime"}
            ],
            "Topic": [
                {"name": "topic_id", "type": "int"},
                {"name": "name", "type": "varchar"}
            ]
        }
        return Response(schema)